{"name":"Hands-on: Estendendo a Java Validation API","tagline":"Implementando anotações customizadas.","body":"Neste hand-on você intruduzirá em um projeto em andamento uma solução de validação, criando annotations de validação customizadas para dados do tipo java.util.Date, java.lang.Number, e também criando uma annotation para campos de preenchimento obrigatório.\r\n\r\n\r\nTestes unitários:\r\n\r\nNa implementação de componentes reutilizáveis é indispensável o desevolvimento de testes unitários. Para tal foi elaborado um problema que é um cadastro de cidadãos para ingresso nos programas social do governo. Ser um tema simples e cotidiano contribui para o rápido entedimento do código. Através dos testes verificaremos se as implementações atendem os requisitos do negócio e se estão corretas.\r\n\r\n![](https://lh4.googleusercontent.com/oTtONhLtzx3XVaSGIh1dnag_si67dj2hOu401a2GIwWAwE6fHyNIhsyZ7E0trb7XKAdn_rYrIpg0lQ5UzF4szp78666LCAwl1xpEPsTqna_DzuhHZU4TowLZktyCMfJK2Q)\r\n\r\nSiga atentamente as instruções contidas nas três seções a seguir antes de iniciar a execução dos exercícios.\r\n\r\nEste documento também está disponível em [https://docs.google.com/...](https://docs.google.com/document/d/17pHqcyzgc-ITM1H3BIg10HSj13EJ4gePFREPTQutGko/pub)\r\n\r\n\r\n### Requisitos\r\n\r\n* Git\r\n* JDK 1.7.x\r\n* Maven 3.x\r\n* Eclipse Standard IDE\r\n\r\n\r\n### Preparação\r\n\r\nExecutar os seguintes passos para baixar os fontes e gerar o projeto do Eclipse.\r\n\r\n```\r\n> mkdir hands-on\r\n> cd hands-on\r\n> git clone https://github.com/br11/validation_hands-on.git\r\n> cd validation_hands-on\r\n> mvn eclipse:clean eclipse:eclipse\r\n```\r\nVeja o [vídeo](http://youtu.be/CQmD64M-ZJQ) \r\n\r\nApós executar os comandos acima, importe o projeto no eclipse.\r\nCaso não queira usar Maven e Git você podera fazer o download e descompactar o arquivo .zip, criar um projeto no eclipse apontando para a pasta descompactada. No Eclipse, crie duas source folders apontando para *src/main/java* e para *src/test/java*.\r\n\r\nExecute a aplicação.\r\n\r\n### Execução\r\n\r\nExecute os casos de testes que são apresentados para verificar o resultado das implementações que forem feitas.\r\n\r\n\r\n### Exercícios\r\n\r\nÉ necessários que os exercício seja executados em sequência. Durante a codificação, aproveite para explorar o código fonte e analisar as alterações que estão sendo propostas. Sempre execute a aplicação após concluir cada exercício - siga as instruções descritas na sessão Execução.\r\n\r\n**Exercício 1**: Implementar uma annotation para validar campos cujo preenchimento é obrigatório.\r\n\r\n**Exercício 1.1**: Implemente uma annotação, aproveitando a configuração de internacionalização de mensagens de erro.\r\n\r\nRequired.java\r\n\r\n\t@Target({ ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE,\r\n\t\t    ElementType.CONSTRUCTOR, ElementType.PARAMETER })\r\n\t@Retention(RetentionPolicy.RUNTIME)\r\n\t@Constraint(validatedBy = RequiredValidator.class)\r\n\tpublic @interface Required {\r\n\r\n\t\t@Target({ ElementType.METHOD, ElementType.FIELD,\r\n\t\t        ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR,\r\n\t\t        ElementType.PARAMETER })\r\n\t\t@Retention(RetentionPolicy.RUNTIME)\r\n\t\tpublic static @interface List {\r\n\r\n\t\t    Class<?>[] groups() default {};\r\n\r\n\t\t    Class<? extends Payload>[] payload() default {};\r\n\r\n\t\t    Required[] value();\r\n\t\t}\r\n\r\n\t\tString message() default \"{javax.validation.constraints.NotNull.message}\";\r\n\r\n\t\tClass<?>[] groups() default {};\r\n\r\n\t\tClass<? extends Payload>[] payload() default {};\r\n\t}\r\n\r\n<br/>\r\n**Exercício 1.2**: Implementar o validador da annotation que modo que qualquer campo possa ser anotado e que a mensagem de erro possa estar sempre adequada ao tipo de dado.\r\n\r\nRequiredValidator.java\r\n\r\n    private boolean validateBySize(int size, ConstraintValidatorContext context) {\r\n        if (size == 0) {\r\n            buildConstraintViolation(context,\r\n                     \"{javax.validation.constraints.Size.message}\");\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n<br/>\r\n**Exercício 1.3**: Aplicar o componente de tratamento de exceção à tela.\r\n\r\nEmprego.java  \r\n\r\n    public class Emprego {\r\n        private long id;\r\n\r\n        private String cargo;\r\n\r\n        @Required\r\n        private String empresa;\r\n\r\n        @Required\r\n        private Date admissao;\r\n\r\n        @Required(groups = Programas.SeguroDesemprego.class)\r\n        private Date demissao;\r\n\r\n\r\n<br/>\r\n**Exercício 1.4**: Crie um test case para validar o preenchimento dos campos que você acabou de anotar.\r\n\r\nTesteEmprego.java  \r\n\r\n    @Test\r\n    public void testRequired() {\r\n        Emprego bean = new Emprego();\r\n        new TestUtil().checkViolations(bean, \"empresa\", \"admissao\");\r\n\r\n        bean.setEmpresa(\"    \");\r\n        new TestUtil().checkViolations(bean, \"empresa\", \"admissao\");\r\n    }\r\n\r\n\r\n<br/>\r\n**Exercício 1.5**: Crie outro test case para validar os campos obrigatórios para o programa de Seguro Desemprego..\r\n\r\nTesteEmprego.java  \r\n\r\n    @Test\r\n    public void testSeguroDesemprego() {\r\n        Emprego bean = new Emprego();\r\n        new TestUtil(Programas.SeguroDesemprego.class)\r\n                .checkViolations(bean, \"demissao\");\r\n    }\r\n\r\n\r\n\r\n<br/>\r\n**Exercício 2**: Implementar uma annotation para validar campos numéricos. Validar valor máximo e mínimo, e número de casas decimais.\r\n\r\n**Exercício 2.1**: Mais uma vez, implemente uma annotação, aproveitando a configuração de internacionalização de mensagens de erro.\r\n\r\nExceptionHandler.java\r\n\r\n\t@Target({ ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE,\r\n\t\t    ElementType.CONSTRUCTOR, ElementType.PARAMETER })\r\n\t@Retention(RetentionPolicy.RUNTIME)\r\n\t@Constraint(validatedBy = NumericValidator.class)\r\n\tpublic @interface Numeric {\r\n\r\n\t\t@Target({ ElementType.METHOD, ElementType.FIELD,\r\n\t\t        ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR,\r\n\t\t        ElementType.PARAMETER })\r\n\t\t@Retention(RetentionPolicy.RUNTIME)\r\n\t\tpublic static @interface List {\r\n\r\n\t\t    Class<?>[] groups() default {};\r\n\r\n\t\t    Class<? extends Payload>[] payload() default {};\r\n\r\n\t\t    Numeric[] value();\r\n\t\t}\r\n\r\n\t\tpublic static final String CURRENCY = \"#########.##\";\r\n\r\n\t\tString message() default \"{javax.validation.constraints.Digits.message}\";\r\n\r\n\t\tClass<?>[] groups() default {};\r\n\r\n\t\tClass<? extends Payload>[] payload() default {};\r\n\r\n\t\tString value();\r\n\r\n\t\tdouble min() default Double.MIN_VALUE;\r\n\r\n\t\tdouble max() default Double.MAX_VALUE;\r\n\t}\r\n\r\n<br/>\r\n**Exercício 2.2**: Implementar o validador da annotation que modo que qualquer campo possa ser anotado e que a mensagem de erro possa estar sempre adequada ao tipo da violação ocorrida.\r\n\r\nNumericValidator.java\r\n\r\n        public boolean isValid(Object value, ConstraintValidatorContext context) {\r\n                if (!requiredValidator.isValid(value, context)) {\r\n                        return true;\r\n                }\r\n\r\n                BigDecimal big = util.toBig(value);\r\n                if (big.compareTo(min) < 0 && big.compareTo(max) > 0) {\r\n                        buildConstraintViolation(context,\r\n                                 \"{br.atech.workshop.validation.Range.message}\");\r\n                        return false;\r\n\r\n                } else if (big.compareTo(min) < 0) {\r\n                        buildConstraintViolation(context,\r\n                                 \"{javax.validation.constraints.Min.message}\");\r\n                        return false;\r\n\r\n                } else if (big.compareTo(max) > 0) {\r\n                        buildConstraintViolation(context,\r\n                                 \"{javax.validation.constraints.Max.message}\");\r\n                        return false;\r\n\r\n                } else if (!util.isValid(value, integerSize, fractionSize)) {\r\n                        return false;\r\n                }\r\n                return true;\r\n        }\r\n\r\n<br/>\r\n**Exercício 2.3**: Aplicaque uma validação ao campo último salário de modo que este não possa ser igual a zero e a parte inteira não ultrapasse 9 digitos.\r\n\r\nEmprego.java\r\n\r\n        @Numeric(value = \"#########.##\", min = 0.01)\r\n        private BigDecimal ultimoSalario;\r\n\r\n<br/>\r\n**Exercício 2.4**: Crie um test case para validar o valor do campo que você acabou de anotar.\r\n\r\nTesteEmprego.java  \r\n\r\n    @Test\r\n    public void testUltimoSalario() {\r\n        Emprego bean = new Emprego();\r\n        bean.setEmpresa(\"XPTO\");\r\n        bean.setAdmissao(new Date());\r\n\r\n        /* salário ok */\r\n        bean.setUltimoSalario(new BigDecimal(\"10000.250\"));\r\n        new TestUtil().checkViolations(bean);\r\n\r\n        /* excesso de casas decimais */\r\n        bean.setUltimoSalario(new BigDecimal(\"10000.001\"));\r\n        new TestUtil().checkViolations(bean, \"ultimoSalario\");\r\n\r\n        /* excede o valor máximo permitido para o campo */\r\n        bean.setUltimoSalario(new BigDecimal(\"1000000000.00\"));\r\n        new TestUtil().checkViolations(bean, \"ultimoSalario\");\r\n    }\r\n\r\n<br/>\r\n**Exercício 3**: Agora chegou o grande momento que todos esperavam: implementar uma validação de datas.\r\n\r\n**Exercício 3.1**: Implemente uma annotation para validar datas que já possua um conjunto de restrições pré-definidas para que o usuário escolha. Deixe a mensagem de erro vazia para indicar que esta dever ser dinamicamente gerada a partir da restrição que foi violada.\r\n\r\nDateRange.java\r\n\r\n\t\tString message() default \"\";\r\n\r\n\t\tClass<?>[] groups() default {};\r\n\r\n\t\tClass<? extends Payload>[] payload() default {};\r\n\r\n\t\tRanges min() default Ranges.Past;\r\n\t\tRanges max() default Ranges.Future;\r\n\r\n\t\tint minGap() default 0;\r\n\t\tint maxGap() default 0;\r\n\r\n\t\tRanges[] value() default Ranges.Any;\r\n\t}\r\n\r\n<br/>\r\n**Exercício 3.2**: No validador da annotation, implemente a geração dinâmica da mensagem de erro.\r\n\r\nDateRangeValidator.java\r\n\r\n    private void buildConstraintViolation(ConstraintValidatorContext context,\r\n            Ranges... ranges) {\r\n        context.disableDefaultConstraintViolation();\r\n        for (Ranges range : ranges) {\r\n            context.buildConstraintViolationWithTemplate(\r\n                    range.getErrorMessage()).addConstraintViolation();\r\n        }\r\n    }\r\n\r\n<br/>\r\n**Exercício 3.3**: Aplicaque uma validação ao campo data de nascimento do menor de idade. A regra é que o cadastro é válido até o final do mês em que o menor completa 18 anos.\r\n\r\nMenorDeIdade.java\r\n\r\n\tpublic class MenorDeIdade {\r\n\t\t@Required\r\n\t\tprivate String nome;\r\n\r\n\t\t@DateRange(min = DateRange.Ranges.ThisMonth, minGap = -18 * 12,\r\n\t\t             groups = Programas.BolsaFamilia.class)\r\n\r\n\t\t@Required(groups = Programas.BolsaFamilia.class)\r\n\t\tprivate Date dataDeNascimento;\r\n\r\n<br/>\r\n**Exercício 3.4**: Crie um test case para validar o valor do campo que você acabou de anotar.\r\n\r\nTesteMenorDeIdade.java  \r\n\r\n    @Test\r\n    public void testBolsaFamiliaMenorIdade() {\r\n        MenorDeIdade bean = new MenorDeIdade();\r\n        bean.setNome(\"fulano de tal\");\r\n\r\n        /* idades em meses */\r\n        int recemNascido = 0;\r\n        int dezoito = (18 * 12);\r\n        int idadeAdultaQualquer = (21 * 12); // 21 anos\r\n\r\n        /* de recem nascido à 17 anos de idade é válido */\r\n        for (int idade = recemNascido; idade < dezoito; idade++) {\r\n            bean.setDataDeNascimento(util.calculaDataDeNascimento((char) idade));\r\n            new TestUtil(Programas.BolsaFamilia.class).checkViolations(bean);\r\n        }\r\n\r\n        /*\r\n         * No dia em que completa dezoito anos é válido.\r\n         */\r\n        Date dezoitoExatos = util.calculaDataDeNascimento((char) dezoito);\r\n        bean.setDataDeNascimento(dezoitoExatos);\r\n        new TestUtil(Programas.BolsaFamilia.class).checkViolations(bean);\r\n\r\n        /*\r\n         * dezoito anos e uns dias - requisito diz ser valido até o final mês em\r\n         * que completa a maioridade.\r\n         */\r\n        Date inicioDoMes = util.set(dezoitoExatos, Calendar.DAY_OF_MONTH, 1);\r\n        bean.setDataDeNascimento(inicioDoMes);\r\n        new TestUtil(Programas.BolsaFamilia.class).checkViolations(bean);\r\n\r\n        /* prestes a completar 18 anos é válido */\r\n        Date fimDoMes = util.set(dezoitoExatos, Calendar.DAY_OF_MONTH, 28);\r\n        bean.setDataDeNascimento(fimDoMes);\r\n        new TestUtil(Programas.BolsaFamilia.class).checkViolations(bean);\r\n\r\n        /* 18 anos 1 um mês ou mais não é válido */\r\n        for (int idade = idadeAdultaQualquer; idade > dezoito; idade--) {\r\n            bean.setDataDeNascimento(util.calculaDataDeNascimento((char) idade));\r\n            new TestUtil(Programas.BolsaFamilia.class).checkViolations(bean,\r\n                    \"dataDeNascimento\");\r\n        }\r\n    }","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}